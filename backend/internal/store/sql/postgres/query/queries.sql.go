// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package query

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const changePassword = `-- name: ChangePassword :exec
UPDATE
    users
SET
    passhash = $2
WHERE
    username = $1
`

type ChangePasswordParams struct {
	Username string
	Passhash []byte
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) error {
	_, err := q.db.ExecContext(ctx, changePassword, arg.Username, arg.Passhash)
	return err
}

const createPost = `-- name: CreatePost :exec
INSERT INTO posts (id, username, cover_hash, images, description, tags, location)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreatePostParams struct {
	ID          int64
	Username    string
	CoverHash   sql.NullString
	Images      []string
	Description sql.NullString
	Tags        []string
	Location    sql.NullString
}

// CreatePost creates a new post.
func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) error {
	_, err := q.db.ExecContext(ctx, createPost,
		arg.ID,
		arg.Username,
		arg.CoverHash,
		pq.Array(arg.Images),
		arg.Description,
		pq.Array(arg.Tags),
		arg.Location,
	)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (token, username, expiry, metadata)
    VALUES ($1, $2, new_session_expiry (), $3)
RETURNING
    token, username, expiry, metadata
`

type CreateSessionParams struct {
	Token    string
	Username string
	Metadata json.RawMessage
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.Token, arg.Username, arg.Metadata)
	var i Session
	err := row.Scan(
		&i.Token,
		&i.Username,
		&i.Expiry,
		&i.Metadata,
	)
	return i, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, passhash)
    VALUES ($1, $2)
`

type CreateUserParams struct {
	Username string
	Passhash []byte
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.Username, arg.Passhash)
	return err
}

const deletePost = `-- name: DeletePost :execrows
DELETE FROM posts
WHERE id = $1
    AND username = $2
`

type DeletePostParams struct {
	ID       int64
	Username string
}

// DeletePost deletes a post.
func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePost, arg.ID, arg.Username)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE token = $1
`

// TODO: consider returning an indication
func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const getPost = `-- name: GetPost :one
SELECT
    posts.id, posts.username, posts.cover_hash, posts.images, posts.description, posts.tags, posts.location,
    count_likes (posts.id) AS likes,
    (
        SELECT
            COUNT(*)
        FROM
            liked_posts
        WHERE
            liked_posts.post_id = posts.id
            AND liked_posts.username = $2) AS liked
FROM
    posts
WHERE
    posts.id = $1
LIMIT 1
`

type GetPostParams struct {
	ID       int64
	Username string
}

type GetPostRow struct {
	ID          int64
	Username    string
	CoverHash   sql.NullString
	Images      []string
	Description sql.NullString
	Tags        []string
	Location    sql.NullString
	Likes       int64
	Liked       int64
}

// GetPost gets a single post.
func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (GetPostRow, error) {
	row := q.db.QueryRowContext(ctx, getPost, arg.ID, arg.Username)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CoverHash,
		pq.Array(&i.Images),
		&i.Description,
		pq.Array(&i.Tags),
		&i.Location,
		&i.Likes,
		&i.Liked,
	)
	return i, err
}

const likePost = `-- name: LikePost :exec
INSERT INTO liked_posts (post_id, username, liked_at)
    VALUES ($1, $2, now())
`

type LikePostParams struct {
	PostID   int64
	Username string
}

// LikePost likes a post.
func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) error {
	_, err := q.db.ExecContext(ctx, likePost, arg.PostID, arg.Username)
	return err
}

const likedPosts = `-- name: LikedPosts :many
SELECT
    posts.id, posts.username, posts.cover_hash, posts.images, posts.description, posts.tags, posts.location,
    count_likes (posts.id) AS likes
FROM
    posts
WHERE
    posts.id IN (
        SELECT
            liked_posts.post_id
        FROM
            liked_posts
        WHERE
            liked_posts.username = $1)
`

type LikedPostsRow struct {
	ID          int64
	Username    string
	CoverHash   sql.NullString
	Images      []string
	Description sql.NullString
	Tags        []string
	Location    sql.NullString
	Likes       int64
}

// LikedPosts returns a user's liked posts.
func (q *Queries) LikedPosts(ctx context.Context, username string) ([]LikedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, likedPosts, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LikedPostsRow
	for rows.Next() {
		var i LikedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.CoverHash,
			pq.Array(&i.Images),
			&i.Description,
			pq.Array(&i.Tags),
			&i.Location,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPosts = `-- name: NextPosts :many
SELECT
    posts.id, posts.username, posts.cover_hash, posts.images, posts.description, posts.tags, posts.location,
    count_likes (posts.id) AS likes,
    (
        SELECT
            COUNT(*)
        FROM
            liked_posts
        WHERE
            liked_posts.post_id = posts.id
            AND liked_posts.username = $2) AS liked
FROM
    posts
WHERE
    posts.id < $1
    OR $1 = 0
ORDER BY
    posts.id DESC
LIMIT 10
`

type NextPostsParams struct {
	ID       int64
	Username string
}

type NextPostsRow struct {
	ID          int64
	Username    string
	CoverHash   sql.NullString
	Images      []string
	Description sql.NullString
	Tags        []string
	Location    sql.NullString
	Likes       int64
	Liked       int64
}

// NextPosts paginates the list of posts.
func (q *Queries) NextPosts(ctx context.Context, arg NextPostsParams) ([]NextPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, nextPosts, arg.ID, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NextPostsRow
	for rows.Next() {
		var i NextPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.CoverHash,
			pq.Array(&i.Images),
			&i.Description,
			pq.Array(&i.Tags),
			&i.Location,
			&i.Likes,
			&i.Liked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postLikeCount = `-- name: PostLikeCount :one
SELECT
    COUNT(*)
FROM
    liked_posts
WHERE
    post_id = $1
`

// PostLikeCount returns the like count of the post with the given ID.
func (q *Queries) PostLikeCount(ctx context.Context, postID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, postLikeCount, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const self = `-- name: Self :one
SELECT
    username, display_name, avatar, bio, birthday, food_preferences
FROM
    private_users
WHERE
    username = $1
LIMIT 1
`

// Self gets the current user's private data.
func (q *Queries) Self(ctx context.Context, username string) (PrivateUser, error) {
	row := q.db.QueryRowContext(ctx, self, username)
	var i PrivateUser
	err := row.Scan(
		&i.Username,
		&i.DisplayName,
		&i.Avatar,
		&i.Bio,
		&i.Birthday,
		&i.FoodPreferences,
	)
	return i, err
}

const tokenExists = `-- name: TokenExists :one
SELECT
    COUNT(*)
FROM
    sessions
WHERE
    token = $1
`

// TokenExists returns 1 if the token exists or 0.
func (q *Queries) TokenExists(ctx context.Context, token string) (int64, error) {
	row := q.db.QueryRowContext(ctx, tokenExists, token)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const unlikePost = `-- name: UnlikePost :exec
DELETE FROM liked_posts
WHERE post_id = $1
    AND username = $2
`

type UnlikePostParams struct {
	PostID   int64
	Username string
}

// UnlikePost removes a like of the current user from a post.
func (q *Queries) UnlikePost(ctx context.Context, arg UnlikePostParams) error {
	_, err := q.db.ExecContext(ctx, unlikePost, arg.PostID, arg.Username)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE
    users
SET
    display_name = $2,
    avatar = $3,
    bio = $4,
    birthday = $5,
    food_preferences = $6
WHERE
    username = $1
`

type UpdateUserParams struct {
	Username        string
	DisplayName     sql.NullString
	Avatar          sql.NullString
	Bio             sql.NullString
	Birthday        sql.NullTime
	FoodPreferences json.RawMessage
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Username,
		arg.DisplayName,
		arg.Avatar,
		arg.Bio,
		arg.Birthday,
		arg.FoodPreferences,
	)
	return err
}

const user = `-- name: User :one
SELECT
    username, display_name, avatar, bio
FROM
    public_users
WHERE
    username = $1
LIMIT 1
`

// User gets any user's public data.
func (q *Queries) User(ctx context.Context, username string) (PublicUser, error) {
	row := q.db.QueryRowContext(ctx, user, username)
	var i PublicUser
	err := row.Scan(
		&i.Username,
		&i.DisplayName,
		&i.Avatar,
		&i.Bio,
	)
	return i, err
}

const userPasshash = `-- name: UserPasshash :one
SELECT
    passhash
FROM
    users
WHERE
    username = $1
LIMIT 1
`

// UserPasshash gets a user's password hash.
func (q *Queries) UserPasshash(ctx context.Context, username string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, userPasshash, username)
	var passhash []byte
	err := row.Scan(&passhash)
	return passhash, err
}

const validateSession = `-- name: ValidateSession :one
UPDATE
    sessions
SET
    expiry = new_session_expiry ()
WHERE
    token = $1
    AND expiry < now()
RETURNING
    username,
    expiry,
    metadata
`

type ValidateSessionRow struct {
	Username string
	Expiry   time.Time
	Metadata json.RawMessage
}

// ValidateSession validates the session and returns the username. An error is
// returned if the session doesn't exist anymore.
func (q *Queries) ValidateSession(ctx context.Context, token string) (ValidateSessionRow, error) {
	row := q.db.QueryRowContext(ctx, validateSession, token)
	var i ValidateSessionRow
	err := row.Scan(&i.Username, &i.Expiry, &i.Metadata)
	return i, err
}
